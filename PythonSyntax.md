# PYTHON

## `ЛЕКЦИЯ 01`

1. Кроссплатформенность
2. Подходит для:
   - Веб-сервисов;
   - ML (Meta Language), DataScience, Аналитики;
   - Игр
   - Написание софта
3. Интерпретируемый
4. Исполняемый файл запустится на компьютере только если в системе установлен интерпретатор Python

```Python
print("Hello, Мир !")
print("И Вам здравствуйте!")
```

**Python - язык с динамической типизацией**

В то же время справедливы типы данных: `int, boolean, float, str, list` и т.д.

### <u>Присваивание:</u>

```Python
a = 25
b = 17
name = 'Jane' # Строка
name: str = 'Kate' # Явное указание типа
```

> Строка выделяется кавычками (одинарными или двойными)
> Если в тексте строки есть кавычки, то можно:
>
> 1. Если текст включает двойные кавычки, то строку текста выделяем одинарными (и наоборот)
>
> ```Python
> text_1 = "Так называемые 'партнёры'"
> text_2 = 'Так называемые "партнёры"'
> ```
>
> 2. Можно использовать escape-последовательности
>
> ```Python
> text_3 = 'Так называемые \'партнёры\''
> ```

> <span style="color:#00f0f0">**_Нельзя объявить переменную без присваивания ей значения,
> но, если очень хочется, то можно присвоить пустое значение:_**</span>
>
> ```Python
> value = None
> ```

### <u>Вывод данных:</u>

```Python
print(name)
```

### <u>Вывод типа данных переменной:</u>

```Python
print(type(name))
```

### <u>Форматирование строки:</u>

```Python
var1 = 5
var2 = 7
var3 = 14
print(var1, '-', var2, '-', var3) # 5 - 7 - 14
print('{} - {} - {}'.format(var1, var2, var3)) # 5 - 7 - 14
print('{1} - {2} - {0}'.format(var1, var2, var3)) # 7 - 14 - 5
print(f'{var1} - {var2} - {var3}') # 5 - 7 - 14
```

### <u>Логические переменные:</u>

```Python
t = True
f = False
print(t)
print(f)
```

## <u>Массивы / Списки</u>

> `В Python нет Массивов, но есть Списки`

```Python
list = ['1', '2', '3', '4', 'Hello']
print(list)
```

> `Пробел в начале строки может "сломать" программу - отступ означает вложенность`

### <u>Ввод данных:</u>

```Python
a = int(input("Введите число а: ")) # Преобразуем вводимую строку в целое число
print(a)

a = float(input("Введите число а: ")) # Преобразуем вводимую строку в число с плавающей точкой
print(a)
```

> НО! Если не преобразовать вводимое значение, то оно будет в формате строки, а не числа

```Python
a = input("Введите число x: ") # 12
b = input("Введите число y: ") # 80
print(a + b) # 1280
```

### <u>Арифметические операции:</u>

`+, -, *, / - основные арифметические операции`

`% - остаток от деления`

`// - целочисленное деление`

`** - возведение в степень`

`(+) - унарный плюс` # Например +5

`(-) - унарный минус` # Например -5

> <span style="color:#00f0f0">**_Остаток от деления числа с плавающей точкой на 1 позволяет получить его дробную часть_**</span>

> `2.56 % 1 = 0.56`

### <u>Приоритет операций:</u>

`**, (+), (-), *, /, //, %, +, -`

> Скобки ( ) меняют приоритет

### <u>Математические функции:</u>

```Python
a = 1.3
b = 3
c = a * b
print(c) # 3.9000000000000004
print(round(c, 5)) # 3.9
print(round(a * b)) # 4
```

### <u>Сокращенные операции присваивания:</u>

```Python
a = 3
a +=5 # 8 (a = a + 5)
```

> `Действует аналогично для всех арифметических операций`

### <u>Логические операции:</u>

`>, >=, <, <=, ==, !=` - операции сравнения <span style="color:#00f0f0">(оба операнда должны иметь один и тот же тип _!_)</span>

`not, and, or` - логические операторы

`in, not in` - оператор `in` возвращает `True`, если в наборе значений есть данное значение, `not in` при этом возвращает `False`

```Python
message = 'Hello, World!'
print('Hello' in message) # True
```

`is, is not` - проверяет, это тот же объект, или нет (например, копия - это другой объект и `==` даст True, а `is` даст False)

### <u>Поразрядные операции:</u>

#### _<u>Двоичное представление чисел</u>_

```Python
number_one = 5 # Число в десятичной форме
number_two = 0b1011 # Число в двоичной форме
print('number_one = {:0b}'.format(number_one)) # 101 (Выводим десятичное число в двоичной форме)
print('number_two = {}'.format(number_one)) # 11 Выводим двоичное число в десятичной форме
```

#### _<u>Поразрядные логические операции</u>_

`&` Поразрядное логическое умножение

`|` Поразрядное логическое сложение

`^` Поразрядное исключающее "или"

`~` Инверсия (~x = -(x + 1)) # Например, если x = 5, то ~x = -6

#### _<u>Операции сдвига</u>_

```Python
x << y # Сдвигает число x на y разрядов влево (по сути, умножает его на 2**y)
x >> y # Сдвигает число x на y разрядов вправо (по сути, делит его на 2**y)
16 << 1 # 32 (Умножает 16 на 2)
16 >> 1 # 8 (Делит 16 на 2)
15 << 1 # 30 (Умножает 15 на 2)
15 >> 1 # 7 (Делит 15 на 2, получаем целочисленное деление)
```

#### _<u>Множественное сравнение</u>_

```Python
a = 1 < 5 < 3
print('a = {}'.format(a)) # False
a = 1 < 5 > 3
print('a = {}'.format(a)) # True
```

#### _<u>Логика в списках</u>_

```Python
f = [1, 2, 3, 4]
print(2 in f)  # True (В списке f есть 2)
print(not 2 in f)  # True (В списке f есть 2)
```

#### _<u>Проверка на чётность</u>_

```Python
is_even = f[0] % 2 == 0  # False (1 - число нечётное)

# (f[0] % 2 равно 1, то есть True, not True - это False)
is_even = not f[0] % 2 # False
```

### <u>Управляющие конструкции (if, if-else):</u>

> `Отступы - часть синтаксиса. Неправильно сделанные отступы могут поломать всё ветвление`

#### _<u>if, if-else</u>_

```Python
username = input('Введите Ваше имя: ')
if (username == 'Маша'):
   print('Ура! Это же Маша!')
else:
   print(f'Здравствуй, {username}')
```

#### _<u>if - elif - else</u>_

```Python
username = input('Введите Ваше имя: ')
if (username == 'Маша'):
   print('Ура! Это же Маша!')
elif (username == 'Маша'):
   print('Мы так ждали тебя, Марина !')
elif (username == 'Ильнар'):
   print('Ильнар - топ ! :-)')
else:
   print(f'Здравствуй, {username}')
```

> `При выполнении одного из условий цепочки, остальные части цепочки не будут выполняться`

#### _<u>Тернарный оператор</u>_

_Первый вариант_

```Python
is_nice = True
state = "nice" if is_nice else "not nice"
```

_Второй вариант (использование кортежей)_

```Python
var = (if_test_is_false, if_test_is_true)[test] # Шаблон

nice = True
personality = ("вредная", "добрая")[nice]
print("Кошка ", personality)
# Вывод: Кошка добрая
```

_Сокращенный тернарный оператор_

```Python
True or "Some"
# Вывод: True

False or "Some"
# Вывод: 'Some'
```

```Python
func_output = None
msg = func_output or "Не было возвращено данных"
print(msg)
# Вывод: Не было возвращено данных
```

#### _<u>while</u>_

```Python
original = 235
print('Исходное число равно {}'.format(original))
inverted = 0
while (original != 0):
    inverted = inverted * 10 + original % 10
    original //= 10
    print(inverted)
print('Инвертированное число равно {}'.format(inverted))
```

#### _<u>while - else</u>_

```Python
original = 235
print('Исходное число равно {}'.format(original))
inverted = 0
while (original != 0):
    inverted = inverted * 10 + original % 10
    original //= 10
    print(inverted)
else:
   print('Инвертированное число равно {}'.format(inverted))
print('Наконец-то конец !')
```

### <u>Цикл for:</u>

#### _<u>Перебор списка</u>_

```Python
for i in 1, 2, 3, 4, 5:
    print(i)
```

#### _<u>Перебор строки</u>_

```Python
stranger_name = 'Владислав'
for i in stranger_name:
    print(i)
```

#### _<u>Перебор диапазона</u>_

```Python
n = 3
for i in range(-n, (n + 1)):
    print(i)
```

#### _<u>Перебор с шагом</u>_

```Python
for i in range(0, 10, 2):
    print(i)
```

### <u>Работа со строками:</u>

```Python
text = 'съешь ещё этих мягких французских булок'

print(len(text)) # 39
print('ещё' in text) # True
print(text.isdigit()) # False
print(text.islower()) # True
print(text.replace('ещё', 'ЕЩЁ'))
```

> Если в строке встречается ескейп-последовательность, то можно сделать её недействующей
> следующим образом:
>
> ```Python
> path = r"C:\python\name.txt"
> print(path)
> ```
>
> В пути к файлу есть последоватеьность символов \n (перевод строки),
> но её действие отключено символом r непосредственно перед строкой

#### _<u>Срезы строк</u>_

```Python
print(text[0]) # c
print(text[1]) # ъ
print(text[len(text)]) # Index Error (нумерация с нуля до (len(text) - 1))
print(text[len(text) - 1]) # к
print(text[-5]) # б (Если закольцевать текст и идти от элемента [0] влево, то будет элемент [-1], затем [-2] и т.д.)
print(text[:]) # то же, что и print(text)
print(text[:2]) # съ (От элемента [0] включительно до элемента [2] исключительно)
print(text[len(text)-2:]) # ок (От второго элемента с конца строки до последнего элемента)
print(text[-2:]) # ок (По сути, предыдущий вариант)
print(text[2:9]) # ешь ещё (элементы от [2] включительлно до [9] исключительно)
print(text[22:-14] + text[-11] + text[-4]) # фразу
print(text[::6]) # сеикакл (Выборка с элемента [0] каждый 6-й элемент до конца)
```

> Допускается обращаться к элементу строки как к элементу массива (text [ i ]) для получения его значения,
> но невозможно таким образом изменить это значение (text [ i ] = 5 не работает).
> Строка - элемент типа immutable (неизменяемый). Можно только присвоить новое значение целиком всей строке.

#### _<u>Введение в списки</u>_

```Python
numbers = [1, 2, 3, 4, 5]  # Самый простой способ создания списка
ran = range(1, 6)  # range - это отдельный тип
print(type(ran))  # <class 'range'>
numbers = list(ran)  # Приведение типа range к типу list
print(type(numbers))  # <class 'list'>

numbers[0] = 10
print(numbers)  # [10, 2, 3, 4, 5]

for i in numbers:
    print(i**2)  # В цикле выводит в столбик квадраты переменной i (100, 4, 9, 16, 25),
print(numbers)  # но не изменяет сами элементы списка [10, 2, 3, 4, 5]
```

#### _<u>Списки строк</u>_

```Python
colors = ['red', 'green', 'blue']
print(colors)  # ['red', 'green', 'blue']
print(colors * 2)  # ['red', 'green', 'blue', 'red', 'green', 'blue']

for e in colors:
    print(e)  # red green blue в цикле столбиком

for e in colors:
    print(e * 2)  # redred greengreen blueblue в цикле столбиком

colors.append('grey')  # Добавляем элемент в конец списка
print(colors)  # ['red', 'green', 'blue', 'grey']

print(colors == ['red', 'green', 'blue', 'grey'])  # True

colors.remove('red')  # Удаляет указанный элемент (альтернатива: del colors[0])
print(colors)  # ['green', 'blue', 'grey']

del colors[0]
print(colors)  # ['blue', 'grey']

del colors[-1]
print(colors)  # ['blue']
```

#### _<u>Функции</u>_

```Python
# Общая форма описания функции
def function_name(x):
    # Line 1
    # Line 2
    x += 2
    # optional return x

# Описание функции f(x)
def f(x):
    if x == 1:
        return 'Целое'
    elif x == 2.3:
        return 23
    else:
        return

# Вызовы функции f(x) с разными параметрами
arg = 1
print(f(arg))  # Целое
print(type(f(arg)))  # <class 'str'>

arg = 2.3
print(f(arg))  # 23
print(type(f(arg)))  # <class 'int'>

arg = 2
print(f(arg))  # None
print(type(f(arg)))  # <class 'NoneType'>
```

> `Тип возвращаемого функцией значения зависит от самого значения и не является свойством функции`

#### _<u>Кое-что о встроенной справке Python</u>_

```Python
text = 'cъешь ещё этих мягких французских булок'
help(text.islower)
```

> При запуске этого кода выдаст встроенную справку Python об islower
>
> Если при выводе справки в конце её пульсирует двоеточие, то переходим в это окно и жмём **q**

## `ЛЕКЦИЯ 02. Данные, функции и модули в Python`

## КАК РАБОТАТЬ С ФАЙЛАМИ

1. **Связать файловую переменную с файлом, определив модификатор работы:**

   - **_a_** - открытие для добавления данных (если файл не существует, то будет создан)
   - **_r_** - открытие для чтения данных (если файл не существует, то будет ошибка)
   - **_w_** - открытие для записи данных (поверх существующих, если файл не существует, то создаётся)
   - **_w+_** - открытие для записи с возможностью чтения (если файла не будет, то он создаётся)
   - **_r+_** - открытие для чтения с возможностью записи (если файла не будет, то будет ошибка)

   ```Python
   colors = ['red', ' ', 'green', ' ', 'blue']
   data = open('Lecture02.txt', 'w') # Открываем файл Lecture02.txt и связываем его с переменной `data`
   ```

2. Записываем данные в файл:
   ```Python
   data.writelines(colors)  # Список из переменной colors. Запишется без разделителей: redgreenblue
   for i in range(5): # В цикле '0', '1', '2', '3', '4'
    data.write(f'\n{str(i)}') # (Для записи int преобразуем в строку, добавляем перевод строки \n)
   ```
3. Не забываем закрыть связь переменной data с файлом:
   ```Python
   data.close()
   ```

## РАБОТА С ФУНКЦИЯМИ ИЗ ДРУГИХ ФАЙЛОВ

`Странно, но файл исполняется целиком сразу после его импорта, без вызова функции`

```Python
import Lecture01 # Подключаем файл Lecture01.py
print(Lecture01.f(1)) # Из файла Lecture01.py запускаем функцию f с аргументом (1)
```

Для замещения имени импортируемого файла можно присвоить ему псевдоним и использовать его вместо имени:

```Python
import Lecture01 as L01 # Подключаем файл Lecture01.py и присваиваем ему псевдоним L01
print(L01.f(1)) # Из файла Lecture01.py, используя его псевдоним, запускаем функцию f с аргументом (1)
```

```Python
from Lecture01 import new_string # Подключаем файл Lecture01.py и присваиваем ему псевдоним L01
print(Lecture01.new_string('Вау! ')) # Из файла Lecture01.py, используя его псевдоним, запускаем функцию f с аргументом (1)
```

## АРГУМЕНТЫ ПО УМОЛЧАНИЮ

Обычное использование:

```Python
def new_string(symbol, count):
    return(symbol * count)
print(new_string('!', 5)) # '!!!!!'
print(new_string('!')) # TypeError missing 1 requared ... (Ошибка отсутствия аргумента)
```

Использование значений по умолчанию:

```Python
def new_string(symbol, count = 3):
    return(symbol * count)
print(new_string('!', 5)) # '!!!!!' Если введены все аргументы
print(new_string('!')) # '!!!' Если не введён второй аргумент, то берётся значение по умолчанию
print(new_string(4)) # 12 Тип переменной определяется в момент вызова функции, поэтому symbol будет int
```

> Аргументы, которым назначены значения по умолчанию, при описании и вызове функции указываются последними

## НЕОГРАНИЧЕННОЕ КОЛИЧЕСТВО АРГУМЕНТОВ

```Python
def concatenatio(*params):
    res: str = ""
    for item in params:
        res += item
    return res
print(concatenatio('a', 's', 'd', 'w')) # asdw
print(concatenatio('a', '1', 'd', '2')) # a1d2
print(concatenatio('a', 'd')) # ad
print(concatenatio(1, 2, 3, 4)) # TypeError: ... (Для чисел склеивание строк не работает)
```

## РЕКУРСИЯ

```Python
# Напечатать первые 9 элементов ряда Фибоначчи
# Рекурсивная функция:
def fib(n):
    if n in [1, 2]:
        return 1
    else:
        return fib(n-1) + fib(n-2)

# Вызов рекурсивной функции:
list = []
for e in range(1, 10):
    list.append(fib(e))
print(list) # 1 1 2 3 5 8 13 21 34
```

## КОРТЕЖИ

```Python
Кортеж - это неизменяемый список
t = ()
print(type(t)) # tuple
t = (1,)
print(type(t)) # tuple
t = (1)
print(type(t)) # int
t = (28, 9, 1990)
print(type(t)) # tuple
colors = ['red', 'green', 'blue']
print(colors) # ['red', 'green', 'blue']
t = tuple(colors)
print(t) # ('red', 'green', 'blue')
```

```Python
a = (3) # Число
a = (3,) # Кортеж из одного элемента
a, b = 3, 4 # Множественное присвоение
a = (3, 4)  # Кортеж
print('a = {}'.format(a))
print(f'type(a) = {type(a)}')  # tuple
print(f'a[0] = {a[0]}')
print(f'a[-1] = {a[-1]}')
a[0] = 12  # Не работает, в отличие от списка, потому что кортеж - список неизменяемый
```

```Python
t = (['red', 'green' , 'blue']) # Преобразуем список в кортеж
red, green, blue = t # Распаковываем кортеж в переменные
print('r:{} g:{} b:{}'.format(red, green, blue)) # r:red g:green b:blue
```

## СЛОВАРИ

Неупорядоченные коллекции произвольных объектов с доступом по ключу

```Python
dictionary = {}
# В следующей строке слэш используется для переноса строки кода без её разрыва
dictionary =\
    {
        'up': '↑',
        2: '←',
        'down': '↓',
        'right':'→'
    }
print(dictionary) # {'up':'↑', 2:'←', 'down':'↓', 'right':'→'}
print(dictionary['up']) # ↑
print(dictionary[2])  # ←
```

```Python
print('\n')
for k in dictionary.keys():
    print(k)  # Распечатываем ключи словаря # up
#                                           # 2
print('\n') #                               # down
for k in dictionary: #                      # right
    print(k)  # Распечатываем ключи словаря

print('\n')
for k in dictionary.values():
    print(k)  # Распечатываем элементы словаря  # ↑
#                                               # ←
print('\n') #                                   # ↓
for v in dictionary: #                          # →
    print(dictionary[v])  # Распечатываем элементы словаря

del dictionary['right']  # Удаляем элемент по ключу 'right'
print(dictionary)

dictionary['right'] = '→'  # Добавляем элемент по ключу 'right'
print(dictionary)

print('\n')
for item in dictionary:
    # Печатаем ключ и значение элемента:
    print('{}: {}'.format(item, dictionary[item]))
```

> Типы ключей могут отличаться

## МНОЖЕСТВА

```Python
print('\n')

colors = {'red', 'green', 'blue'}
print(type(colors))  # <class 'set'>
print(colors)  # {'blue', 'green', 'red'}

colors.add('red')  # Такой элемент есть, поэтому ничего не изменится
print(colors)  # {'blue', 'green', 'red'}

colors.add('grey')  # Добавляем элемент
print(colors)  # {'blue', 'green', 'red', 'grey'}

colors.remove('red')  # Удаляем элемент
print(colors)  # {'blue', 'green', 'grey'}

colors.remove('red')  # KeyError: 'red' Удаление несуществующего элемента

colors.discard('red') # Удаляет элемент, если он есть, не выводит ошибку, если его нет

colors.clear()  # {} Очищаем множество
print(colors)  # set() (Пустое множество)

# К множествам можно применять объединение, пересечение и пр. по теории множеств:
a = {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 21}
c = a.copy()  # c = {1, 2, 3, 5, 8}
u = a.union(b)  # u = {1,2,3,5,8,13,21}
i = a.intersection(b)  # i = {2, 5, 8}
dl = a.difference(b)  # dl = {1, 3}
dr = b.difference(a)  # dr = {13, 21}

q = a\
    .union(b)\
    .difference(a.intersection(b))
print(q) # {1,21,3,13}

# НЕИЗМЕНЯЕМЫЕ МНОЖЕСТВА

# Никакие действия с добавлением или удалением элементов не действуют на s
s = frozenset(a)
```

## СПИСКИ

```Python
list1 = [1, 2, 3, 4, 5]
list2 = list1  # Так делать не надо, так как это не копия списка, а ещё одна ссылка на тот же список

print('\n ')
print(list1)  # Печатаем список [1, 2, 3, 4, 5]
```

### `ИЗЪЯТИЕ ПОСЛЕДНЕГО ЭЛЕМЕНТА СПИСКА`

```Python
lst = list1.pop()  # Извлекли в переменную последний элемент списка (5)
print(lst)  # Печатаем извлечённый элемент (5)
print(list1)  # Печатаем остаток списка [1, 2, 3, 4]

# По этой ссылке (list2) тоже удалён последний элемент [1, 2, 3, 4]
print(list2)
lst_2 = list1.pop(2)  # Извлекли в переменную элемент списка с индексом 2
print(lst_2)  # Печатаем удалённый элемент с индексом [2] (3)
print(list1)  # Печатаем остаток списка [1, 2, 4]
```

### `ВСТАВКА ЭЛЕМЕНТА В ОПРЕДЕЛЁННУЮ ПОЗИЦИЮ СПИСКА`

```Python
print(list1.insert(2, 3))  # None (Вставляем после 2 элемента элемент (3)
print(list1)  # Печатаем список [1, 2, 3, 4]
```

### `ДОБАВЛЕНИЕ ЭЛЕМЕНТА В КОНЕЦ СПИСКА`

```Python
list1.append(5)  # Добавляем элемент (5) в конец списка
print(list2)  # [1, 2, 3, 4, 5]
```
